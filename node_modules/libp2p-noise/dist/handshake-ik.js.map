{"version":3,"sources":["../src/handshake-ik.ts"],"names":["IKHandshake","constructor","isInitiator","payload","prologue","staticKeypair","connection","remoteStaticKey","remotePeer","handshake","Buffer","from","ik","IK","session","initSession","remoteEarlyData","alloc","stage0","hs","s","rs","messageBuffer","sendMessage","writeLP","e","receivedMsg","readLP","receivedMessageBuffer","slice","plaintext","valid","recvMessage","Error","decodedPayload","setRemoteEarlyData","data","re","FailedIKError","message","stage1","ns","decrypt","ciphertext","cs","getCS","decryptWithAd","encrypt","encryptWithAd","getLocalEphemeralKeys","encryption","cs1","cs2","buffer","byteOffset","length"],"mappings":"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","sourcesContent":["import {WrappedConnection} from \"./noise\";\nimport {IK} from \"./handshakes/ik\";\nimport {NoiseSession} from \"./@types/handshake\";\nimport {bytes, bytes32} from \"./@types/basic\";\nimport {KeyPair} from \"./@types/libp2p\";\nimport {IHandshake} from \"./@types/handshake-interface\";\nimport {Buffer} from \"buffer\";\nimport {decode0, decode1, encode0, encode1} from \"./encoder\";\nimport {decodePayload, getPeerIdFromPayload, verifySignedPayload} from \"./utils\";\nimport {FailedIKError} from \"./errors\";\nimport {\n  logger, \n  logLocalStaticKeys,\n  logRemoteStaticKey, \n  logLocalEphemeralKeys, \n  logRemoteEphemeralKey, \n  logCipherState\n} from \"./logger\";\nimport PeerId from \"peer-id\";\n\nexport class IKHandshake implements IHandshake {\n  public isInitiator: boolean;\n  public session: NoiseSession;\n  public remotePeer!: PeerId;\n  public remoteEarlyData: Buffer;\n\n  private payload: bytes;\n  private prologue: bytes32;\n  private staticKeypair: KeyPair;\n  private connection: WrappedConnection;\n  private ik: IK;\n\n  constructor(\n    isInitiator: boolean,\n    payload: bytes,\n    prologue: bytes32,\n    staticKeypair: KeyPair,\n    connection: WrappedConnection,\n    remoteStaticKey: bytes,\n    remotePeer?: PeerId,\n    handshake?: IK,\n  ) {\n    this.isInitiator = isInitiator;\n    this.payload = Buffer.from(payload);\n    this.prologue = prologue;\n    this.staticKeypair = staticKeypair;\n    this.connection = connection;\n    if(remotePeer) {\n      this.remotePeer = remotePeer;\n    }\n    this.ik = handshake || new IK();\n    this.session = this.ik.initSession(this.isInitiator, this.prologue, this.staticKeypair, remoteStaticKey);\n    this.remoteEarlyData = Buffer.alloc(0)\n  }\n\n  public async stage0(): Promise<void> {\n    logLocalStaticKeys(this.session.hs.s)\n    logRemoteStaticKey(this.session.hs.rs)\n    if (this.isInitiator) {\n      logger(\"IK Stage 0 - Initiator sending message...\");\n      const messageBuffer = this.ik.sendMessage(this.session, this.payload);\n      this.connection.writeLP(encode1(messageBuffer));\n      logger(\"IK Stage 0 - Initiator sent message.\");\n      logLocalEphemeralKeys(this.session.hs.e)\n    } else {\n      logger(\"IK Stage 0 - Responder receiving message...\");\n      const receivedMsg = await this.connection.readLP();\n      try {\n        const receivedMessageBuffer = decode1(receivedMsg.slice());\n        const {plaintext, valid} = this.ik.recvMessage(this.session, receivedMessageBuffer);\n        if(!valid) {\n          throw new Error(\"ik handshake stage 0 decryption validation fail\");\n        }\n        logger(\"IK Stage 0 - Responder got message, going to verify payload.\");\n        const decodedPayload = await decodePayload(plaintext);\n        this.remotePeer = this.remotePeer || await getPeerIdFromPayload(decodedPayload);\n        await verifySignedPayload(this.session.hs.rs, decodedPayload, this.remotePeer);\n        this.setRemoteEarlyData(decodedPayload.data);\n        logger(\"IK Stage 0 - Responder successfully verified payload!\");\n        logRemoteEphemeralKey(this.session.hs.re)\n      } catch (e) {\n        logger(\"Responder breaking up with IK handshake in stage 0.\");\n\n        throw new FailedIKError(receivedMsg, `Error occurred while verifying initiator's signed payload: ${e.message}`);\n      }\n    }\n  }\n\n  public async stage1(): Promise<void> {\n    if (this.isInitiator) {\n      logger(\"IK Stage 1 - Initiator receiving message...\");\n      const receivedMsg = (await this.connection.readLP()).slice();\n      const receivedMessageBuffer = decode0(Buffer.from(receivedMsg));\n      const {plaintext, valid} = this.ik.recvMessage(this.session, receivedMessageBuffer);\n      logger(\"IK Stage 1 - Initiator got message, going to verify payload.\");\n      try {\n        if(!valid) {\n          throw new Error(\"ik stage 1 decryption validation fail\");\n        }\n        const decodedPayload = await decodePayload(plaintext);\n        this.remotePeer = this.remotePeer || await getPeerIdFromPayload(decodedPayload);\n        await verifySignedPayload(receivedMessageBuffer.ns.slice(0, 32), decodedPayload, this.remotePeer);\n        this.setRemoteEarlyData(decodedPayload.data);\n        logger(\"IK Stage 1 - Initiator successfully verified payload!\");\n        logRemoteEphemeralKey(this.session.hs.re)\n      } catch (e) {\n        logger(\"Initiator breaking up with IK handshake in stage 1.\");\n        throw new FailedIKError(receivedMsg, `Error occurred while verifying responder's signed payload: ${e.message}`);\n      }\n    } else {\n      logger(\"IK Stage 1 - Responder sending message...\");\n      const messageBuffer = this.ik.sendMessage(this.session, this.payload);\n      this.connection.writeLP(encode0(messageBuffer));\n      logger(\"IK Stage 1 - Responder sent message...\");\n      logLocalEphemeralKeys(this.session.hs.e)\n    }\n    logCipherState(this.session)\n  }\n\n  public decrypt(ciphertext: bytes, session: NoiseSession): {plaintext: bytes; valid: boolean} {\n    const cs = this.getCS(session, false);\n    return this.ik.decryptWithAd(cs, Buffer.alloc(0), ciphertext);\n  }\n\n  public encrypt(plaintext: Buffer, session: NoiseSession): Buffer {\n    const cs = this.getCS(session);\n    return this.ik.encryptWithAd(cs, Buffer.alloc(0), plaintext);\n  }\n\n  public getLocalEphemeralKeys(): KeyPair {\n    if (!this.session.hs.e) {\n      throw new Error(\"Ephemeral keys do not exist.\");\n    }\n\n    return this.session.hs.e;\n  }\n\n  private getCS(session: NoiseSession, encryption = true) {\n    if (!session.cs1 || !session.cs2) {\n      throw new Error(\"Handshake not completed properly, cipher state does not exist.\");\n    }\n\n    if (this.isInitiator) {\n      return encryption ? session.cs1 : session.cs2;\n    } else {\n      return encryption ? session.cs2 : session.cs1;\n    }\n  }\n\n  private setRemoteEarlyData(data: Uint8Array|null|undefined): void {\n    if(data){\n      this.remoteEarlyData = Buffer.from(data.buffer, data.byteOffset, data.length);\n    }\n  }\n}\n"],"file":"handshake-ik.js"}