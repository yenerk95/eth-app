"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.generateKeypair = generateKeypair;
exports.getPayload = getPayload;
exports.createHandshakePayload = createHandshakePayload;
exports.signPayload = signPayload;
exports.getPeerIdFromPayload = getPeerIdFromPayload;
exports.decodePayload = decodePayload;
exports.getHandshakePayload = getHandshakePayload;
exports.verifySignedPayload = verifySignedPayload;
exports.getHkdf = getHkdf;
exports.isValidPublicKey = isValidPublicKey;

var _hkdf = _interopRequireDefault(require("bcrypto/lib/hkdf"));

var _x = _interopRequireDefault(require("bcrypto/lib/js/x25519"));

var _sha = _interopRequireDefault(require("bcrypto/lib/js/sha256"));

var _buffer = require("buffer");

var _peerId = _interopRequireDefault(require("peer-id"));

var _libp2pCrypto = require("libp2p-crypto");

var _payload = require("./proto/payload");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const NoiseHandshakePayloadProto = _payload.pb.NoiseHandshakePayload;

function generateKeypair() {
  const privateKey = _x.default.privateKeyGenerate();

  const publicKey = _x.default.publicKeyCreate(privateKey);

  return {
    publicKey,
    privateKey
  };
}

async function getPayload(localPeer, staticPublicKey, earlyData) {
  const signedPayload = await signPayload(localPeer, getHandshakePayload(staticPublicKey));

  const earlyDataPayload = earlyData || _buffer.Buffer.alloc(0);

  return await createHandshakePayload(localPeer.marshalPubKey(), signedPayload, earlyDataPayload);
}

async function createHandshakePayload(libp2pPublicKey, signedPayload, earlyData) {
  const payloadInit = NoiseHandshakePayloadProto.create({
    identityKey: libp2pPublicKey,
    identitySig: signedPayload,
    data: earlyData || null
  });
  return _buffer.Buffer.from(NoiseHandshakePayloadProto.encode(payloadInit).finish());
}

async function signPayload(peerId, payload) {
  return peerId.privKey.sign(payload);
}

async function getPeerIdFromPayload(payload) {
  return await _peerId.default.createFromPubKey(_buffer.Buffer.from(payload.identityKey));
}

async function decodePayload(payload) {
  return NoiseHandshakePayloadProto.toObject(NoiseHandshakePayloadProto.decode(_buffer.Buffer.from(payload)));
}

function getHandshakePayload(publicKey) {
  return _buffer.Buffer.concat([_buffer.Buffer.from("noise-libp2p-static-key:"), publicKey]);
}

async function isValidPeerId(peerId, publicKeyProtobuf) {
  const generatedPeerId = await _peerId.default.createFromPubKey(publicKeyProtobuf);
  return generatedPeerId.id.equals(peerId);
}
/**
 * Verifies signed payload, throws on any irregularities.
 * @param {bytes} noiseStaticKey - owner's noise static key
 * @param {bytes} payload - decoded payload
 * @param {PeerId} remotePeer - owner's libp2p peer ID
 * @returns {Promise<PeerId>} - peer ID of payload owner
 */


async function verifySignedPayload(noiseStaticKey, payload, remotePeer) {
  const identityKey = _buffer.Buffer.from(payload.identityKey);

  if (!(await isValidPeerId(remotePeer.id, identityKey))) {
    throw new Error("Peer ID doesn't match libp2p public key.");
  }

  const generatedPayload = getHandshakePayload(noiseStaticKey); // Unmarshaling from PublicKey protobuf

  const publicKey = _libp2pCrypto.keys.unmarshalPublicKey(identityKey);

  if (!payload.identitySig || !publicKey.verify(generatedPayload, _buffer.Buffer.from(payload.identitySig))) {
    throw new Error("Static key doesn't match to peer that signed payload!");
  }

  return _peerId.default.createFromPubKey(identityKey);
}

function getHkdf(ck, ikm) {
  const info = _buffer.Buffer.alloc(0);

  const prk = _hkdf.default.extract(_sha.default, ikm, ck);

  const okm = _hkdf.default.expand(_sha.default, prk, info, 96);

  const k1 = okm.slice(0, 32);
  const k2 = okm.slice(32, 64);
  const k3 = okm.slice(64, 96);
  return [k1, k2, k3];
}

function isValidPublicKey(pk) {
  return _x.default.publicKeyVerify(pk.slice(0, 32));
}
//# sourceMappingURL=utils.js.map