"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Noise = void 0;

var _x = _interopRequireDefault(require("bcrypto/lib/js/x25519"));

var _buffer = require("buffer");

var _itPbRpc = _interopRequireDefault(require("it-pb-rpc"));

var _duplex = _interopRequireDefault(require("it-pair/duplex"));

var _itBuffer = _interopRequireDefault(require("it-buffer"));

var _itPipe = _interopRequireDefault(require("it-pipe"));

var _itLengthPrefixed = require("it-length-prefixed");

var _handshakeXx = require("./handshake-xx");

var _handshakeIk = require("./handshake-ik");

var _handshakeXxFallback = require("./handshake-xx-fallback");

var _utils = require("./utils");

var _encoder = require("./encoder");

var _crypto = require("./crypto");

var _keycache = require("./keycache");

var _logger = require("./logger");

var _constants = require("./constants");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class Noise {
  /**
   *
   * @param staticNoiseKey x25519 private key, reuse for faster handshakes
   * @param earlyData
   */
  constructor(staticNoiseKey, earlyData) {
    _defineProperty(this, "protocol", "/noise");

    _defineProperty(this, "prologue", _buffer.Buffer.alloc(0));

    _defineProperty(this, "staticKeys", void 0);

    _defineProperty(this, "earlyData", void 0);

    _defineProperty(this, "useNoisePipes", void 0);

    this.earlyData = earlyData || _buffer.Buffer.alloc(0); //disabled until properly specked

    this.useNoisePipes = false;

    if (staticNoiseKey) {
      const publicKey = _x.default.publicKeyCreate(staticNoiseKey);

      this.staticKeys = {
        privateKey: staticNoiseKey,
        publicKey
      };
    } else {
      this.staticKeys = (0, _utils.generateKeypair)();
    }
  }
  /**
   * Encrypt outgoing data to the remote party (handshake as initiator)
   * @param {PeerId} localPeer - PeerId of the receiving peer
   * @param connection - streaming iterable duplex that will be encrypted
   * @param {PeerId} remotePeer - PeerId of the remote peer. Used to validate the integrity of the remote peer.
   * @returns {Promise<SecureOutbound>}
   */


  async secureOutbound(localPeer, connection, remotePeer) {
    const wrappedConnection = (0, _itPbRpc.default)(connection, {
      lengthEncoder: _encoder.uint16BEEncode,
      lengthDecoder: _encoder.uint16BEDecode,
      maxDataLength: _constants.NOISE_MSG_MAX_LENGTH_BYTES
    });
    const handshake = await this.performHandshake({
      connection: wrappedConnection,
      isInitiator: true,
      localPeer,
      remotePeer
    });
    const conn = await this.createSecureConnection(wrappedConnection, handshake);
    return {
      conn,
      remoteEarlyData: handshake.remoteEarlyData,
      remotePeer: handshake.remotePeer
    };
  }
  /**
   * Decrypt incoming data (handshake as responder).
   * @param {PeerId} localPeer - PeerId of the receiving peer.
   * @param connection - streaming iterable duplex that will be encryption.
   * @param {PeerId} remotePeer - optional PeerId of the initiating peer, if known. This may only exist during transport upgrades.
   * @returns {Promise<SecureOutbound>}
   */


  async secureInbound(localPeer, connection, remotePeer) {
    const wrappedConnection = (0, _itPbRpc.default)(connection, {
      lengthEncoder: _encoder.uint16BEEncode,
      lengthDecoder: _encoder.uint16BEDecode,
      maxDataLength: _constants.NOISE_MSG_MAX_LENGTH_BYTES
    });
    const handshake = await this.performHandshake({
      connection: wrappedConnection,
      isInitiator: false,
      localPeer,
      remotePeer
    });
    const conn = await this.createSecureConnection(wrappedConnection, handshake);
    return {
      conn,
      remoteEarlyData: handshake.remoteEarlyData,
      remotePeer: handshake.remotePeer
    };
  }
  /**
   * If Noise pipes supported, tries IK handshake first with XX as fallback if it fails.
   * If noise pipes disabled or remote peer static key is unknown, use XX.
   * @param params
   */


  async performHandshake(params) {
    const payload = await (0, _utils.getPayload)(params.localPeer, this.staticKeys.publicKey, this.earlyData);
    let tryIK = this.useNoisePipes;

    if (params.isInitiator && _keycache.KeyCache.load(params.remotePeer) === null) {
      //if we are initiator and remote static key is unknown, don't try IK
      tryIK = false;
    } // Try IK if acting as responder or initiator that has remote's static key.


    if (tryIK) {
      // Try IK first
      const {
        remotePeer,
        connection,
        isInitiator
      } = params;
      const ikHandshake = new _handshakeIk.IKHandshake(isInitiator, payload, this.prologue, this.staticKeys, connection, //safe to cast as we did checks
      _keycache.KeyCache.load(params.remotePeer) || _buffer.Buffer.alloc(32), remotePeer);

      try {
        return await this.performIKHandshake(ikHandshake);
      } catch (e) {
        // IK failed, go to XX fallback
        let ephemeralKeys;

        if (params.isInitiator) {
          ephemeralKeys = ikHandshake.getLocalEphemeralKeys();
        }

        return await this.performXXFallbackHandshake(params, payload, e.initialMsg, ephemeralKeys);
      }
    } else {
      // run XX handshake
      return await this.performXXHandshake(params, payload);
    }
  }

  async performXXFallbackHandshake(params, payload, initialMsg, ephemeralKeys) {
    const {
      isInitiator,
      remotePeer,
      connection
    } = params;
    const handshake = new _handshakeXxFallback.XXFallbackHandshake(isInitiator, payload, this.prologue, this.staticKeys, connection, initialMsg, remotePeer, ephemeralKeys);

    try {
      await handshake.propose();
      await handshake.exchange();
      await handshake.finish();
    } catch (e) {
      (0, _logger.logger)(e);
      throw new Error(`Error occurred during XX Fallback handshake: ${e.message}`);
    }

    return handshake;
  }

  async performXXHandshake(params, payload) {
    const {
      isInitiator,
      remotePeer,
      connection
    } = params;
    const handshake = new _handshakeXx.XXHandshake(isInitiator, payload, this.prologue, this.staticKeys, connection, remotePeer);

    try {
      await handshake.propose();
      await handshake.exchange();
      await handshake.finish();

      if (this.useNoisePipes && handshake.remotePeer) {
        _keycache.KeyCache.store(handshake.remotePeer, handshake.getRemoteStaticKey());
      }
    } catch (e) {
      throw new Error(`Error occurred during XX handshake: ${e.message}`);
    }

    return handshake;
  }

  async performIKHandshake(handshake) {
    await handshake.stage0();
    await handshake.stage1();
    return handshake;
  }

  async createSecureConnection(connection, handshake) {
    // Create encryption box/unbox wrapper
    const [secure, user] = (0, _duplex.default)();
    const network = connection.unwrap();
    (0, _itPipe.default)(secure, // write to wrapper
    _itBuffer.default, // ensure any type of data is converted to buffer
    (0, _crypto.encryptStream)(handshake), // data is encrypted
    (0, _itLengthPrefixed.encode)({
      lengthEncoder: _encoder.uint16BEEncode
    }), // prefix with message length
    network, // send to the remote peer
    (0, _itLengthPrefixed.decode)({
      lengthDecoder: _encoder.uint16BEDecode
    }), // read message length prefix
    _itBuffer.default, // ensure any type of data is converted to buffer
    (0, _crypto.decryptStream)(handshake), // decrypt the incoming data
    secure // pipe to the wrapper
    );
    return user;
  }

}

exports.Noise = Noise;
//# sourceMappingURL=noise.js.map