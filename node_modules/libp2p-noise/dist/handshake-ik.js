"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.IKHandshake = void 0;

var _ik = require("./handshakes/ik");

var _buffer = require("buffer");

var _encoder = require("./encoder");

var _utils = require("./utils");

var _errors = require("./errors");

var _logger = require("./logger");

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class IKHandshake {
  constructor(isInitiator, payload, prologue, staticKeypair, connection, remoteStaticKey, remotePeer, handshake) {
    _defineProperty(this, "isInitiator", void 0);

    _defineProperty(this, "session", void 0);

    _defineProperty(this, "remotePeer", void 0);

    _defineProperty(this, "remoteEarlyData", void 0);

    _defineProperty(this, "payload", void 0);

    _defineProperty(this, "prologue", void 0);

    _defineProperty(this, "staticKeypair", void 0);

    _defineProperty(this, "connection", void 0);

    _defineProperty(this, "ik", void 0);

    this.isInitiator = isInitiator;
    this.payload = _buffer.Buffer.from(payload);
    this.prologue = prologue;
    this.staticKeypair = staticKeypair;
    this.connection = connection;

    if (remotePeer) {
      this.remotePeer = remotePeer;
    }

    this.ik = handshake || new _ik.IK();
    this.session = this.ik.initSession(this.isInitiator, this.prologue, this.staticKeypair, remoteStaticKey);
    this.remoteEarlyData = _buffer.Buffer.alloc(0);
  }

  async stage0() {
    (0, _logger.logLocalStaticKeys)(this.session.hs.s);
    (0, _logger.logRemoteStaticKey)(this.session.hs.rs);

    if (this.isInitiator) {
      (0, _logger.logger)("IK Stage 0 - Initiator sending message...");
      const messageBuffer = this.ik.sendMessage(this.session, this.payload);
      this.connection.writeLP((0, _encoder.encode1)(messageBuffer));
      (0, _logger.logger)("IK Stage 0 - Initiator sent message.");
      (0, _logger.logLocalEphemeralKeys)(this.session.hs.e);
    } else {
      (0, _logger.logger)("IK Stage 0 - Responder receiving message...");
      const receivedMsg = await this.connection.readLP();

      try {
        const receivedMessageBuffer = (0, _encoder.decode1)(receivedMsg.slice());
        const {
          plaintext,
          valid
        } = this.ik.recvMessage(this.session, receivedMessageBuffer);

        if (!valid) {
          throw new Error("ik handshake stage 0 decryption validation fail");
        }

        (0, _logger.logger)("IK Stage 0 - Responder got message, going to verify payload.");
        const decodedPayload = await (0, _utils.decodePayload)(plaintext);
        this.remotePeer = this.remotePeer || (await (0, _utils.getPeerIdFromPayload)(decodedPayload));
        await (0, _utils.verifySignedPayload)(this.session.hs.rs, decodedPayload, this.remotePeer);
        this.setRemoteEarlyData(decodedPayload.data);
        (0, _logger.logger)("IK Stage 0 - Responder successfully verified payload!");
        (0, _logger.logRemoteEphemeralKey)(this.session.hs.re);
      } catch (e) {
        (0, _logger.logger)("Responder breaking up with IK handshake in stage 0.");
        throw new _errors.FailedIKError(receivedMsg, `Error occurred while verifying initiator's signed payload: ${e.message}`);
      }
    }
  }

  async stage1() {
    if (this.isInitiator) {
      (0, _logger.logger)("IK Stage 1 - Initiator receiving message...");
      const receivedMsg = (await this.connection.readLP()).slice();
      const receivedMessageBuffer = (0, _encoder.decode0)(_buffer.Buffer.from(receivedMsg));
      const {
        plaintext,
        valid
      } = this.ik.recvMessage(this.session, receivedMessageBuffer);
      (0, _logger.logger)("IK Stage 1 - Initiator got message, going to verify payload.");

      try {
        if (!valid) {
          throw new Error("ik stage 1 decryption validation fail");
        }

        const decodedPayload = await (0, _utils.decodePayload)(plaintext);
        this.remotePeer = this.remotePeer || (await (0, _utils.getPeerIdFromPayload)(decodedPayload));
        await (0, _utils.verifySignedPayload)(receivedMessageBuffer.ns.slice(0, 32), decodedPayload, this.remotePeer);
        this.setRemoteEarlyData(decodedPayload.data);
        (0, _logger.logger)("IK Stage 1 - Initiator successfully verified payload!");
        (0, _logger.logRemoteEphemeralKey)(this.session.hs.re);
      } catch (e) {
        (0, _logger.logger)("Initiator breaking up with IK handshake in stage 1.");
        throw new _errors.FailedIKError(receivedMsg, `Error occurred while verifying responder's signed payload: ${e.message}`);
      }
    } else {
      (0, _logger.logger)("IK Stage 1 - Responder sending message...");
      const messageBuffer = this.ik.sendMessage(this.session, this.payload);
      this.connection.writeLP((0, _encoder.encode0)(messageBuffer));
      (0, _logger.logger)("IK Stage 1 - Responder sent message...");
      (0, _logger.logLocalEphemeralKeys)(this.session.hs.e);
    }

    (0, _logger.logCipherState)(this.session);
  }

  decrypt(ciphertext, session) {
    const cs = this.getCS(session, false);
    return this.ik.decryptWithAd(cs, _buffer.Buffer.alloc(0), ciphertext);
  }

  encrypt(plaintext, session) {
    const cs = this.getCS(session);
    return this.ik.encryptWithAd(cs, _buffer.Buffer.alloc(0), plaintext);
  }

  getLocalEphemeralKeys() {
    if (!this.session.hs.e) {
      throw new Error("Ephemeral keys do not exist.");
    }

    return this.session.hs.e;
  }

  getCS(session, encryption = true) {
    if (!session.cs1 || !session.cs2) {
      throw new Error("Handshake not completed properly, cipher state does not exist.");
    }

    if (this.isInitiator) {
      return encryption ? session.cs1 : session.cs2;
    } else {
      return encryption ? session.cs2 : session.cs1;
    }
  }

  setRemoteEarlyData(data) {
    if (data) {
      this.remoteEarlyData = _buffer.Buffer.from(data.buffer, data.byteOffset, data.length);
    }
  }

}

exports.IKHandshake = IKHandshake;
//# sourceMappingURL=handshake-ik.js.map