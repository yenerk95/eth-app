{"version":3,"sources":["../src/noise.ts"],"names":["Noise","constructor","staticNoiseKey","earlyData","Buffer","alloc","useNoisePipes","publicKey","x25519","publicKeyCreate","staticKeys","privateKey","secureOutbound","localPeer","connection","remotePeer","wrappedConnection","lengthEncoder","uint16BEEncode","lengthDecoder","uint16BEDecode","maxDataLength","NOISE_MSG_MAX_LENGTH_BYTES","handshake","performHandshake","isInitiator","conn","createSecureConnection","remoteEarlyData","secureInbound","params","payload","tryIK","KeyCache","load","ikHandshake","IKHandshake","prologue","performIKHandshake","e","ephemeralKeys","getLocalEphemeralKeys","performXXFallbackHandshake","initialMsg","performXXHandshake","XXFallbackHandshake","propose","exchange","finish","Error","message","XXHandshake","store","getRemoteStaticKey","stage0","stage1","secure","user","network","unwrap","ensureBuffer"],"mappings":"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","sourcesContent":["import x25519 from 'bcrypto/lib/js/x25519';\nimport {Buffer} from \"buffer\";\nimport Wrap from 'it-pb-rpc';\nimport DuplexPair from 'it-pair/duplex';\nimport ensureBuffer from 'it-buffer';\nimport pipe from 'it-pipe';\nimport {encode, decode} from 'it-length-prefixed';\n\nimport {XXHandshake} from \"./handshake-xx\";\nimport {IKHandshake} from \"./handshake-ik\";\nimport {XXFallbackHandshake} from \"./handshake-xx-fallback\";\nimport {generateKeypair, getPayload} from \"./utils\";\nimport {uint16BEDecode, uint16BEEncode} from \"./encoder\";\nimport {decryptStream, encryptStream} from \"./crypto\";\nimport {bytes} from \"./@types/basic\";\nimport {INoiseConnection, KeyPair, SecureOutbound} from \"./@types/libp2p\";\nimport {Duplex} from \"it-pair\";\nimport {IHandshake} from \"./@types/handshake-interface\";\nimport {KeyCache} from \"./keycache\";\nimport {logger} from \"./logger\";\nimport PeerId from \"peer-id\";\nimport {NOISE_MSG_MAX_LENGTH_BYTES} from \"./constants\";\n\nexport type WrappedConnection = ReturnType<typeof Wrap>;\n\ntype HandshakeParams = {\n  connection: WrappedConnection;\n  isInitiator: boolean;\n  localPeer: PeerId;\n  remotePeer?: PeerId;\n};\n\nexport class Noise implements INoiseConnection {\n  public protocol = \"/noise\";\n\n  private readonly prologue = Buffer.alloc(0);\n  private readonly staticKeys: KeyPair;\n  private readonly earlyData?: bytes;\n  private useNoisePipes: boolean;\n\n  /**\n   *\n   * @param staticNoiseKey x25519 private key, reuse for faster handshakes\n   * @param earlyData\n   */\n  constructor(staticNoiseKey?: bytes, earlyData?: bytes) {\n    this.earlyData = earlyData || Buffer.alloc(0);\n    //disabled until properly specked\n    this.useNoisePipes = false;\n\n    if (staticNoiseKey) {\n      const publicKey = x25519.publicKeyCreate(staticNoiseKey);\n      this.staticKeys = {\n        privateKey: staticNoiseKey,\n        publicKey,\n      }\n    } else {\n      this.staticKeys = generateKeypair();\n    }\n  }\n\n  /**\n   * Encrypt outgoing data to the remote party (handshake as initiator)\n   * @param {PeerId} localPeer - PeerId of the receiving peer\n   * @param connection - streaming iterable duplex that will be encrypted\n   * @param {PeerId} remotePeer - PeerId of the remote peer. Used to validate the integrity of the remote peer.\n   * @returns {Promise<SecureOutbound>}\n   */\n  public async secureOutbound(localPeer: PeerId, connection: any, remotePeer: PeerId): Promise<SecureOutbound> {\n    const wrappedConnection = Wrap(\n      connection,\n      {\n        lengthEncoder: uint16BEEncode,\n        lengthDecoder: uint16BEDecode,\n        maxDataLength: NOISE_MSG_MAX_LENGTH_BYTES\n      }\n    );\n    const handshake = await this.performHandshake({\n      connection: wrappedConnection,\n      isInitiator: true,\n      localPeer,\n      remotePeer,\n    });\n    const conn = await this.createSecureConnection(wrappedConnection, handshake);\n\n    return {\n      conn,\n      remoteEarlyData: handshake.remoteEarlyData,\n      remotePeer: handshake.remotePeer,\n    }\n  }\n\n  /**\n   * Decrypt incoming data (handshake as responder).\n   * @param {PeerId} localPeer - PeerId of the receiving peer.\n   * @param connection - streaming iterable duplex that will be encryption.\n   * @param {PeerId} remotePeer - optional PeerId of the initiating peer, if known. This may only exist during transport upgrades.\n   * @returns {Promise<SecureOutbound>}\n   */\n  public async secureInbound(localPeer: PeerId, connection: any, remotePeer?: PeerId): Promise<SecureOutbound> {\n    const wrappedConnection = Wrap(\n      connection,\n      {\n        lengthEncoder: uint16BEEncode,\n        lengthDecoder: uint16BEDecode,\n        maxDataLength: NOISE_MSG_MAX_LENGTH_BYTES\n      }\n    );\n    const handshake = await this.performHandshake({\n      connection: wrappedConnection,\n      isInitiator: false,\n      localPeer,\n      remotePeer\n    });\n    const conn = await this.createSecureConnection(wrappedConnection, handshake);\n\n    return {\n      conn,\n      remoteEarlyData: handshake.remoteEarlyData,\n      remotePeer: handshake.remotePeer\n    };\n  }\n\n  /**\n   * If Noise pipes supported, tries IK handshake first with XX as fallback if it fails.\n   * If noise pipes disabled or remote peer static key is unknown, use XX.\n   * @param params\n   */\n  private async performHandshake(params: HandshakeParams): Promise<IHandshake> {\n    const payload = await getPayload(params.localPeer, this.staticKeys.publicKey, this.earlyData);\n    let tryIK = this.useNoisePipes;\n    if(params.isInitiator && KeyCache.load(params.remotePeer) === null) {\n      //if we are initiator and remote static key is unknown, don't try IK\n      tryIK = false;\n    }\n    // Try IK if acting as responder or initiator that has remote's static key.\n    if (tryIK) {\n      // Try IK first\n      const { remotePeer, connection, isInitiator } = params;\n      const ikHandshake = new IKHandshake(\n        isInitiator,\n        payload,\n        this.prologue,\n        this.staticKeys,\n        connection,\n        //safe to cast as we did checks\n        KeyCache.load(params.remotePeer) || Buffer.alloc(32),\n        remotePeer as PeerId,\n      );\n\n      try {\n        return await this.performIKHandshake(ikHandshake);\n      } catch (e) {\n        // IK failed, go to XX fallback\n        let ephemeralKeys;\n        if (params.isInitiator) {\n          ephemeralKeys = ikHandshake.getLocalEphemeralKeys();\n        }\n        return await this.performXXFallbackHandshake(params, payload, e.initialMsg, ephemeralKeys);\n      }\n    } else {\n      // run XX handshake\n      return await this.performXXHandshake(params, payload);\n    }\n  }\n\n  private async performXXFallbackHandshake(\n    params: HandshakeParams,\n    payload: bytes,\n    initialMsg: bytes,\n    ephemeralKeys?: KeyPair,\n  ): Promise<XXFallbackHandshake> {\n    const { isInitiator, remotePeer, connection } = params;\n    const handshake =\n      new XXFallbackHandshake(isInitiator, payload, this.prologue, this.staticKeys, connection, initialMsg, remotePeer, ephemeralKeys);\n\n    try {\n      await handshake.propose();\n      await handshake.exchange();\n      await handshake.finish();\n    } catch (e) {\n      logger(e);\n      throw new Error(`Error occurred during XX Fallback handshake: ${e.message}`);\n    }\n\n    return handshake;\n  }\n\n  private async performXXHandshake(\n    params: HandshakeParams,\n    payload: bytes,\n  ): Promise<XXHandshake> {\n    const { isInitiator, remotePeer, connection } = params;\n    const handshake = new XXHandshake(isInitiator, payload, this.prologue, this.staticKeys, connection, remotePeer);\n\n    try {\n      await handshake.propose();\n      await handshake.exchange();\n      await handshake.finish();\n\n      if (this.useNoisePipes && handshake.remotePeer) {\n        KeyCache.store(handshake.remotePeer, handshake.getRemoteStaticKey());\n      }\n    } catch (e) {\n      throw new Error(`Error occurred during XX handshake: ${e.message}`);\n    }\n\n    return handshake;\n  }\n\n  private async performIKHandshake(\n    handshake: IKHandshake,\n  ): Promise<IKHandshake> {\n\n    await handshake.stage0();\n    await handshake.stage1();\n\n    return handshake;\n  }\n\n  private async createSecureConnection(\n    connection: WrappedConnection,\n    handshake: IHandshake,\n  ): Promise<Duplex> {\n    // Create encryption box/unbox wrapper\n    const [secure, user] = DuplexPair();\n    const network = connection.unwrap();\n\n    pipe(\n      secure, // write to wrapper\n      ensureBuffer, // ensure any type of data is converted to buffer\n      encryptStream(handshake), // data is encrypted\n      encode({ lengthEncoder: uint16BEEncode }), // prefix with message length\n      network, // send to the remote peer\n      decode({ lengthDecoder: uint16BEDecode}), // read message length prefix\n      ensureBuffer, // ensure any type of data is converted to buffer\n      decryptStream(handshake), // decrypt the incoming data\n      secure // pipe to the wrapper\n    );\n\n    return user;\n  }\n\n\n}\n"],"file":"noise.js"}