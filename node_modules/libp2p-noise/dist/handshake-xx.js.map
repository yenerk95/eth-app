{"version":3,"sources":["../src/handshake-xx.ts"],"names":["XXHandshake","constructor","isInitiator","payload","prologue","staticKeypair","connection","remotePeer","handshake","xx","XX","session","initSession","remoteEarlyData","Buffer","alloc","propose","hs","s","messageBuffer","sendMessage","writeLP","e","receivedMessageBuffer","readLP","slice","valid","recvMessage","Error","re","exchange","plaintext","rs","decodedPayload","ns","setRemoteEarlyData","data","message","finish","encrypt","cs","getCS","encryptWithAd","decrypt","ciphertext","decryptWithAd","getRemoteStaticKey","encryption","cs1","cs2","from","buffer","byteOffset","length"],"mappings":"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","sourcesContent":["import { Buffer } from \"buffer\";\n\nimport { XX } from \"./handshakes/xx\";\nimport { KeyPair } from \"./@types/libp2p\";\nimport { bytes, bytes32 } from \"./@types/basic\";\nimport { NoiseSession } from \"./@types/handshake\";\nimport {IHandshake} from \"./@types/handshake-interface\";\nimport {\n  decodePayload,\n  getPeerIdFromPayload,\n  verifySignedPayload,\n} from \"./utils\";\nimport {\n  logger, \n  logLocalStaticKeys, \n  logLocalEphemeralKeys, \n  logRemoteEphemeralKey, \n  logRemoteStaticKey, \n  logCipherState, \n} from \"./logger\";\nimport {decode0, decode1, decode2, encode0, encode1, encode2} from \"./encoder\";\nimport { WrappedConnection } from \"./noise\";\nimport PeerId from \"peer-id\";\n\nexport class XXHandshake implements IHandshake {\n  public isInitiator: boolean;\n  public session: NoiseSession;\n  public remotePeer!: PeerId;\n  public remoteEarlyData: Buffer;\n\n  protected payload: bytes;\n  protected connection: WrappedConnection;\n  protected xx: XX;\n  protected staticKeypair: KeyPair;\n\n  private prologue: bytes32;\n\n  constructor(\n    isInitiator: boolean,\n    payload: bytes,\n    prologue: bytes32,\n    staticKeypair: KeyPair,\n    connection: WrappedConnection,\n    remotePeer?: PeerId,\n    handshake?: XX,\n  ) {\n    this.isInitiator = isInitiator;\n    this.payload = payload;\n    this.prologue = prologue;\n    this.staticKeypair = staticKeypair;\n    this.connection = connection;\n    if(remotePeer) {\n      this.remotePeer = remotePeer;\n    }\n    this.xx = handshake || new XX();\n    this.session = this.xx.initSession(this.isInitiator, this.prologue, this.staticKeypair);\n    this.remoteEarlyData = Buffer.alloc(0)\n  }\n\n  // stage 0\n  public async propose(): Promise<void> {\n    logLocalStaticKeys(this.session.hs.s)\n    if (this.isInitiator) {\n      logger(\"Stage 0 - Initiator starting to send first message.\");\n      const messageBuffer = this.xx.sendMessage(this.session, Buffer.alloc(0));\n      this.connection.writeLP(encode0(messageBuffer));\n      logger(\"Stage 0 - Initiator finished sending first message.\");\n      logLocalEphemeralKeys(this.session.hs.e)\n    } else {\n      logger(\"Stage 0 - Responder waiting to receive first message...\");\n      const receivedMessageBuffer = decode0((await this.connection.readLP()).slice());\n      const {valid} = this.xx.recvMessage(this.session, receivedMessageBuffer);\n      if(!valid) {\n        throw new Error(\"xx handshake stage 0 validation fail\");\n      }\n      logger(\"Stage 0 - Responder received first message.\");\n      logRemoteEphemeralKey(this.session.hs.re)\n    }\n  }\n\n  // stage 1\n  public async exchange(): Promise<void> {\n    if (this.isInitiator) {\n      logger('Stage 1 - Initiator waiting to receive first message from responder...');\n      const receivedMessageBuffer = decode1((await this.connection.readLP()).slice());\n      const {plaintext, valid} = this.xx.recvMessage(this.session, receivedMessageBuffer);\n      if(!valid) {\n        throw new Error(\"xx handshake stage 1 validation fail\");\n      }\n      logger('Stage 1 - Initiator received the message.');\n      logRemoteEphemeralKey(this.session.hs.re)\n      logRemoteStaticKey(this.session.hs.rs)\n\n      logger(\"Initiator going to check remote's signature...\");\n      try {\n        const decodedPayload = await decodePayload(plaintext);\n        this.remotePeer = this.remotePeer || await getPeerIdFromPayload(decodedPayload);\n        this.remotePeer = await verifySignedPayload(receivedMessageBuffer.ns, decodedPayload, this.remotePeer);\n        this.setRemoteEarlyData(decodedPayload.data)\n      } catch (e) {\n        throw new Error(`Error occurred while verifying signed payload: ${e.message}`);\n      }\n      logger(\"All good with the signature!\");\n    } else {\n      logger('Stage 1 - Responder sending out first message with signed payload and static key.');\n      const messageBuffer = this.xx.sendMessage(this.session, this.payload);\n      this.connection.writeLP(encode1(messageBuffer));\n      logger('Stage 1 - Responder sent the second handshake message with signed payload.')\n      logLocalEphemeralKeys(this.session.hs.e)\n    }\n  }\n\n  // stage 2\n  public async finish(): Promise<void> {\n    if (this.isInitiator) {\n      logger('Stage 2 - Initiator sending third handshake message.');\n      const messageBuffer = this.xx.sendMessage(this.session, this.payload);\n      this.connection.writeLP(encode2(messageBuffer));\n      logger('Stage 2 - Initiator sent message with signed payload.');\n    } else {\n      logger('Stage 2 - Responder waiting for third handshake message...');\n      const receivedMessageBuffer = decode2((await this.connection.readLP()).slice());\n      const {plaintext, valid} = this.xx.recvMessage(this.session, receivedMessageBuffer);\n      if(!valid) {\n        throw new Error(\"xx handshake stage 2 validation fail\");\n      }\n      logger('Stage 2 - Responder received the message, finished handshake.');\n\n      try {\n        const decodedPayload = await decodePayload(plaintext);\n        this.remotePeer = this.remotePeer || await getPeerIdFromPayload(decodedPayload);\n        await verifySignedPayload(this.session.hs.rs, decodedPayload, this.remotePeer);\n        this.setRemoteEarlyData(decodedPayload.data)\n      } catch (e) {\n        throw new Error(`Error occurred while verifying signed payload: ${e.message}`);\n      }\n    }\n    logCipherState(this.session)\n  }\n\n  public encrypt(plaintext: bytes, session: NoiseSession): bytes {\n    const cs = this.getCS(session);\n\n    return this.xx.encryptWithAd(cs, Buffer.alloc(0), plaintext);\n  }\n\n  public decrypt(ciphertext: bytes, session: NoiseSession): {plaintext: bytes; valid: boolean} {\n    const cs = this.getCS(session, false);\n    return this.xx.decryptWithAd(cs, Buffer.alloc(0), ciphertext);\n  }\n\n  public getRemoteStaticKey(): bytes {\n    return this.session.hs.rs;\n  }\n\n  private getCS(session: NoiseSession, encryption = true) {\n    if (!session.cs1 || !session.cs2) {\n      throw new Error(\"Handshake not completed properly, cipher state does not exist.\");\n    }\n\n    if (this.isInitiator) {\n      return encryption ? session.cs1 : session.cs2;\n    } else {\n      return encryption ? session.cs2 : session.cs1;\n    }\n  }\n\n  protected setRemoteEarlyData(data: Uint8Array|null|undefined): void {\n    if(data){\n      this.remoteEarlyData = Buffer.from(data.buffer, data.byteOffset, data.length);\n    }\n  }\n}\n"],"file":"handshake-xx.js"}