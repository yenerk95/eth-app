{"version":3,"sources":["../src/handshake-xx-fallback.ts"],"names":["XXFallbackHandshake","XXHandshake","constructor","isInitiator","payload","prologue","staticKeypair","connection","initialMsg","remotePeer","ephemeralKeys","handshake","propose","xx","sendMessage","session","Buffer","alloc","hs","e","receivedMessageBuffer","valid","recvMessage","ne","ns","ciphertext","Error","re","exchange","plaintext","rs","decodedPayload","setRemoteEarlyData","data","message"],"mappings":";;;;;;;AAAA;;AACA;;AAIA;;AACA;;AAEA;;;;AAGO,MAAMA,mBAAN,SAAkCC,wBAAlC,CAA8C;AAInDC,EAAAA,WAAW,CACTC,WADS,EAETC,OAFS,EAGTC,QAHS,EAITC,aAJS,EAKTC,UALS,EAMTC,UANS,EAOTC,UAPS,EAQTC,aARS,EASTC,SATS,EAUT;AACA,UAAMR,WAAN,EAAmBC,OAAnB,EAA4BC,QAA5B,EAAsCC,aAAtC,EAAqDC,UAArD,EAAiEE,UAAjE,EAA6EE,SAA7E;;AADA;;AAAA;;AAEA,QAAID,aAAJ,EAAmB;AACjB,WAAKA,aAAL,GAAqBA,aAArB;AACD;;AACD,SAAKF,UAAL,GAAkBA,UAAlB;AACD,GApBkD,CAsBnD;;;AACA,QAAaI,OAAb,GAAsC;AACpC,QAAI,KAAKT,WAAT,EAAsB;AACpB,WAAKU,EAAL,CAAQC,WAAR,CAAoB,KAAKC,OAAzB,EAAkCC,eAAOC,KAAP,CAAa,CAAb,CAAlC,EAAmD,KAAKP,aAAxD;AACA,0BAAO,qFAAP;AACA,yCAAsB,KAAKK,OAAL,CAAaG,EAAb,CAAgBC,CAAtC;AACD,KAJD,MAIO;AACL,0BAAO,+DAAP;AACA,YAAMC,qBAAqB,GAAG,sBAAQ,KAAKZ,UAAb,CAA9B;AACA,YAAM;AAACa,QAAAA;AAAD,UAAU,KAAKR,EAAL,CAAQS,WAAR,CAAoB,KAAKP,OAAzB,EAAkC;AAChDQ,QAAAA,EAAE,EAAEH,qBAAqB,CAACG,EADsB;AAEhDC,QAAAA,EAAE,EAAER,eAAOC,KAAP,CAAa,CAAb,CAF4C;AAGhDQ,QAAAA,UAAU,EAAET,eAAOC,KAAP,CAAa,CAAb;AAHoC,OAAlC,CAAhB;;AAKA,UAAG,CAACI,KAAJ,EAAW;AACT,cAAM,IAAIK,KAAJ,CAAU,gDAAV,CAAN;AACD;;AACD,0BAAO,gEAAP;AACA,yCAAsB,KAAKX,OAAL,CAAaG,EAAb,CAAgBS,EAAtC;AACD;AACF,GA1CkD,CA4CnD;;;AACA,QAAaC,QAAb,GAAuC;AACrC,QAAI,KAAKzB,WAAT,EAAsB;AACpB,YAAMiB,qBAAqB,GAAG,sBAAQ,KAAKZ,UAAb,CAA9B;AACA,YAAM;AAACqB,QAAAA,SAAD;AAAYR,QAAAA;AAAZ,UAAqB,KAAKR,EAAL,CAAQS,WAAR,CAAoB,KAAKP,OAAzB,EAAkCK,qBAAlC,CAA3B;;AACA,UAAG,CAACC,KAAJ,EAAW;AACT,cAAM,IAAIK,KAAJ,CAAU,gDAAV,CAAN;AACD;;AACD,0BAAO,gEAAP;AACA,yCAAsB,KAAKX,OAAL,CAAaG,EAAb,CAAgBS,EAAtC;AACA,sCAAmB,KAAKZ,OAAL,CAAaG,EAAb,CAAgBY,EAAnC;AAEA,0BAAO,gDAAP;;AACA,UAAI;AACF,cAAMC,cAAc,GAAG,MAAM,0BAAcF,SAAd,CAA7B;AACA,aAAKpB,UAAL,GAAkB,KAAKA,UAAL,KAAmB,MAAM,iCAAqBsB,cAArB,CAAzB,CAAlB;AACA,cAAM,gCAAoB,KAAKhB,OAAL,CAAaG,EAAb,CAAgBY,EAApC,EAAwCC,cAAxC,EAAwD,KAAKtB,UAA7D,CAAN;AACA,aAAKuB,kBAAL,CAAwBD,cAAc,CAACE,IAAvC;AACD,OALD,CAKE,OAAOd,CAAP,EAAU;AACV,cAAM,IAAIO,KAAJ,CAAW,iEAAgEP,CAAC,CAACe,OAAQ,EAArF,CAAN;AACD;;AACD,0BAAO,8BAAP;AACD,KApBD,MAoBO;AACL,0BAAO,uCAAP;AACA,YAAM,MAAMN,QAAN,EAAN;AACA,0BAAO,qCAAP;AACD;AACF;;AAvEkD","sourcesContent":["import {Buffer} from \"buffer\";\nimport {XXHandshake} from \"./handshake-xx\";\nimport {XX} from \"./handshakes/xx\";\nimport {KeyPair} from \"./@types/libp2p\";\nimport {bytes, bytes32} from \"./@types/basic\";\nimport {decodePayload, getPeerIdFromPayload, verifySignedPayload} from \"./utils\";\nimport {logger, logLocalEphemeralKeys, logRemoteEphemeralKey, logRemoteStaticKey} from \"./logger\";\nimport {WrappedConnection} from \"./noise\";\nimport {decode0, decode1} from \"./encoder\";\nimport PeerId from \"peer-id\";\n\nexport class XXFallbackHandshake extends XXHandshake {\n  private ephemeralKeys?: KeyPair;\n  private initialMsg: bytes;\n\n  constructor(\n    isInitiator: boolean,\n    payload: bytes,\n    prologue: bytes32,\n    staticKeypair: KeyPair,\n    connection: WrappedConnection,\n    initialMsg: bytes,\n    remotePeer?: PeerId,\n    ephemeralKeys?: KeyPair,\n    handshake?: XX,\n  ) {\n    super(isInitiator, payload, prologue, staticKeypair, connection, remotePeer, handshake);\n    if (ephemeralKeys) {\n      this.ephemeralKeys = ephemeralKeys;\n    }\n    this.initialMsg = initialMsg;\n  }\n\n  // stage 0\n  public async propose(): Promise<void> {\n    if (this.isInitiator) {\n      this.xx.sendMessage(this.session, Buffer.alloc(0), this.ephemeralKeys);\n      logger(\"XX Fallback Stage 0 - Initialized state as the first message was sent by initiator.\");\n      logLocalEphemeralKeys(this.session.hs.e)\n    } else {\n      logger(\"XX Fallback Stage 0 - Responder decoding initial msg from IK.\");\n      const receivedMessageBuffer = decode0(this.initialMsg);\n      const {valid} = this.xx.recvMessage(this.session, {\n        ne: receivedMessageBuffer.ne,\n        ns: Buffer.alloc(0),\n        ciphertext: Buffer.alloc(0),\n      });\n      if(!valid) {\n        throw new Error(\"xx fallback stage 0 decryption validation fail\");\n      }\n      logger(\"XX Fallback Stage 0 - Responder used received message from IK.\");\n      logRemoteEphemeralKey(this.session.hs.re)\n    }\n  }\n\n  // stage 1\n  public async exchange(): Promise<void> {\n    if (this.isInitiator) {\n      const receivedMessageBuffer = decode1(this.initialMsg);\n      const {plaintext, valid} = this.xx.recvMessage(this.session, receivedMessageBuffer);\n      if(!valid) {\n        throw new Error(\"xx fallback stage 1 decryption validation fail\");\n      }\n      logger('XX Fallback Stage 1 - Initiator used received message from IK.');\n      logRemoteEphemeralKey(this.session.hs.re)\n      logRemoteStaticKey(this.session.hs.rs)\n\n      logger(\"Initiator going to check remote's signature...\");\n      try {\n        const decodedPayload = await decodePayload(plaintext);\n        this.remotePeer = this.remotePeer || await getPeerIdFromPayload(decodedPayload);\n        await verifySignedPayload(this.session.hs.rs, decodedPayload, this.remotePeer);\n        this.setRemoteEarlyData(decodedPayload.data)\n      } catch (e) {\n        throw new Error(`Error occurred while verifying signed payload from responder: ${e.message}`);\n      }\n      logger(\"All good with the signature!\");\n    } else {\n      logger(\"XX Fallback Stage 1 - Responder start\");\n      await super.exchange();\n      logger(\"XX Fallback Stage 1 - Responder end\");\n    }\n  }\n}\n"],"file":"handshake-xx-fallback.js"}