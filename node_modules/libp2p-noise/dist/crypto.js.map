{"version":3,"sources":["../src/crypto.ts"],"names":["encryptStream","handshake","source","chunk","chunkBuffer","Buffer","from","buffer","byteOffset","length","i","NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG","end","data","encrypt","slice","session","decryptStream","NOISE_MSG_MAX_LENGTH_BYTES","plaintext","decrypted","valid","decrypt","Error"],"mappings":";;;;;;;;AAAA;;AAEA;;;;;;;;;;;;;;;;;;;;AAMA;AACO,SAASA,aAAT,CAAuBC,SAAvB,EAAwE;AAC7E;AAAA,mCAAO,WAAkBC,MAAlB,EAA0B;AAAA;AAAA;;AAAA;;AAAA;AAC/B,4CAA0BA,MAA1B,gOAAkC;AAAA,gBAAjBC,KAAiB;;AAChC,gBAAMC,WAAW,GAAGC,eAAOC,IAAP,CAAYH,KAAK,CAACI,MAAlB,EAA0BJ,KAAK,CAACK,UAAhC,EAA4CL,KAAK,CAACM,MAAlD,CAApB;;AAEA,eAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGN,WAAW,CAACK,MAAhC,EAAwCC,CAAC,IAAIC,iDAA7C,EAAqF;AACnF,gBAAIC,GAAG,GAAGF,CAAC,GAAGC,iDAAd;;AACA,gBAAIC,GAAG,GAAGR,WAAW,CAACK,MAAtB,EAA8B;AAC5BG,cAAAA,GAAG,GAAGR,WAAW,CAACK,MAAlB;AACD;;AAED,kBAAMI,IAAI,GAAGZ,SAAS,CAACa,OAAV,CAAkBV,WAAW,CAACW,KAAZ,CAAkBL,CAAlB,EAAqBE,GAArB,CAAlB,EAA6CX,SAAS,CAACe,OAAvD,CAAb;AACA,kBAAMH,IAAN;AACD;AACF;AAb8B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAchC,KAdD;;AAAA;AAAA;AAAA;AAAA;AAeD,C,CAGD;;;AACO,SAASI,aAAT,CAAuBhB,SAAvB,EAAwE;AAC7E;AAAA,oCAAO,WAAkBC,MAAlB,EAA0B;AAAA;AAAA;;AAAA;;AAAA;AAC/B,6CAA0BA,MAA1B,0OAAkC;AAAA,gBAAjBC,KAAiB;;AAChC,gBAAMC,WAAW,GAAGC,eAAOC,IAAP,CAAYH,KAAK,CAACI,MAAlB,EAA0BJ,KAAK,CAACK,UAAhC,EAA4CL,KAAK,CAACM,MAAlD,CAApB;;AAEA,eAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGN,WAAW,CAACK,MAAhC,EAAwCC,CAAC,IAAIQ,qCAA7C,EAAyE;AACvE,gBAAIN,GAAG,GAAGF,CAAC,GAAGQ,qCAAd;;AACA,gBAAIN,GAAG,GAAGR,WAAW,CAACK,MAAtB,EAA8B;AAC5BG,cAAAA,GAAG,GAAGR,WAAW,CAACK,MAAlB;AACD;;AAED,kBAAMN,KAAK,GAAGC,WAAW,CAACW,KAAZ,CAAkBL,CAAlB,EAAqBE,GAArB,CAAd;AACA,kBAAM;AAACO,cAAAA,SAAS,EAAEC,SAAZ;AAAuBC,cAAAA;AAAvB,2CAAsCpB,SAAS,CAACqB,OAAV,CAAkBnB,KAAlB,EAAyBF,SAAS,CAACe,OAAnC,CAAtC,CAAN;;AACA,gBAAG,CAACK,KAAJ,EAAW;AACT,oBAAM,IAAIE,KAAJ,CAAU,oCAAV,CAAN;AACD;;AACD,kBAAMH,SAAN;AACD;AACF;AAjB8B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAkBhC,KAlBD;;AAAA;AAAA;AAAA;AAAA;AAmBD","sourcesContent":["import { Buffer } from \"buffer\";\nimport {IHandshake} from \"./@types/handshake-interface\";\nimport {NOISE_MSG_MAX_LENGTH_BYTES, NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG} from \"./constants\";\n\ninterface IReturnEncryptionWrapper {\n  (source: Iterable<Uint8Array>): AsyncIterableIterator<Uint8Array>;\n}\n\n// Returns generator that encrypts payload from the user\nexport function encryptStream(handshake: IHandshake): IReturnEncryptionWrapper {\n  return async function * (source) {\n    for await (const chunk of source) {\n      const chunkBuffer = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.length);\n\n      for (let i = 0; i < chunkBuffer.length; i += NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG) {\n        let end = i + NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG;\n        if (end > chunkBuffer.length) {\n          end = chunkBuffer.length;\n        }\n\n        const data = handshake.encrypt(chunkBuffer.slice(i, end), handshake.session);\n        yield data;\n      }\n    }\n  }\n}\n\n\n// Decrypt received payload to the user\nexport function decryptStream(handshake: IHandshake): IReturnEncryptionWrapper {\n  return async function * (source) {\n    for await (const chunk of source) {\n      const chunkBuffer = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.length);\n\n      for (let i = 0; i < chunkBuffer.length; i += NOISE_MSG_MAX_LENGTH_BYTES) {\n        let end = i + NOISE_MSG_MAX_LENGTH_BYTES;\n        if (end > chunkBuffer.length) {\n          end = chunkBuffer.length;\n        }\n\n        const chunk = chunkBuffer.slice(i, end);\n        const {plaintext: decrypted, valid} = await handshake.decrypt(chunk, handshake.session);\n        if(!valid) {\n          throw new Error(\"Failed to validate decrypted chunk\");\n        }\n        yield decrypted;\n      }\n    }\n  }\n}\n"],"file":"crypto.js"}