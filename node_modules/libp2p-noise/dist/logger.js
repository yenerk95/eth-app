"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.logLocalStaticKeys = logLocalStaticKeys;
exports.logLocalEphemeralKeys = logLocalEphemeralKeys;
exports.logRemoteStaticKey = logRemoteStaticKey;
exports.logRemoteEphemeralKey = logRemoteEphemeralKey;
exports.logCipherState = logCipherState;
exports.logger = void 0;

var _debug = _interopRequireDefault(require("debug"));

var _constants = require("./constants");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const logger = (0, _debug.default)('libp2p:noise');
exports.logger = logger;
let keyLogger;

if (_constants.DUMP_SESSION_KEYS) {
  keyLogger = logger;
} else {
  keyLogger = () => {
    /* do nothing */
  };
}

function logLocalStaticKeys(s) {
  keyLogger(`LOCAL_STATIC_PUBLIC_KEY ${s.publicKey.toString('hex')}`);
  keyLogger(`LOCAL_STATIC_PRIVATE_KEY ${s.privateKey.toString('hex')}`);
}

function logLocalEphemeralKeys(e) {
  if (e) {
    keyLogger(`LOCAL_PUBLIC_EPHEMERAL_KEY ${e.publicKey.toString('hex')}`);
    keyLogger(`LOCAL_PRIVATE_EPHEMERAL_KEY ${e.privateKey.toString('hex')}`);
  } else {
    keyLogger('Missing local ephemeral keys.');
  }
}

function logRemoteStaticKey(rs) {
  keyLogger(`REMOTE_STATIC_PUBLIC_KEY ${rs.toString('hex')}`);
}

function logRemoteEphemeralKey(re) {
  keyLogger(`REMOTE_EPHEMERAL_PUBLIC_KEY ${re.toString('hex')}`);
}

function logCipherState(session) {
  if (session.cs1 && session.cs2) {
    keyLogger(`CIPHER_STATE_1 ${session.cs1.n} ${session.cs1.k.toString('hex')}`);
    keyLogger(`CIPHER_STATE_2 ${session.cs2.n} ${session.cs2.k.toString('hex')}`);
  } else {
    keyLogger('Missing cipher state.');
  }
}
//# sourceMappingURL=logger.js.map