"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.XXHandshake = void 0;

var _buffer = require("buffer");

var _xx = require("./handshakes/xx");

var _utils = require("./utils");

var _logger = require("./logger");

var _encoder = require("./encoder");

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class XXHandshake {
  constructor(isInitiator, payload, prologue, staticKeypair, connection, remotePeer, handshake) {
    _defineProperty(this, "isInitiator", void 0);

    _defineProperty(this, "session", void 0);

    _defineProperty(this, "remotePeer", void 0);

    _defineProperty(this, "remoteEarlyData", void 0);

    _defineProperty(this, "payload", void 0);

    _defineProperty(this, "connection", void 0);

    _defineProperty(this, "xx", void 0);

    _defineProperty(this, "staticKeypair", void 0);

    _defineProperty(this, "prologue", void 0);

    this.isInitiator = isInitiator;
    this.payload = payload;
    this.prologue = prologue;
    this.staticKeypair = staticKeypair;
    this.connection = connection;

    if (remotePeer) {
      this.remotePeer = remotePeer;
    }

    this.xx = handshake || new _xx.XX();
    this.session = this.xx.initSession(this.isInitiator, this.prologue, this.staticKeypair);
    this.remoteEarlyData = _buffer.Buffer.alloc(0);
  } // stage 0


  async propose() {
    (0, _logger.logLocalStaticKeys)(this.session.hs.s);

    if (this.isInitiator) {
      (0, _logger.logger)("Stage 0 - Initiator starting to send first message.");
      const messageBuffer = this.xx.sendMessage(this.session, _buffer.Buffer.alloc(0));
      this.connection.writeLP((0, _encoder.encode0)(messageBuffer));
      (0, _logger.logger)("Stage 0 - Initiator finished sending first message.");
      (0, _logger.logLocalEphemeralKeys)(this.session.hs.e);
    } else {
      (0, _logger.logger)("Stage 0 - Responder waiting to receive first message...");
      const receivedMessageBuffer = (0, _encoder.decode0)((await this.connection.readLP()).slice());
      const {
        valid
      } = this.xx.recvMessage(this.session, receivedMessageBuffer);

      if (!valid) {
        throw new Error("xx handshake stage 0 validation fail");
      }

      (0, _logger.logger)("Stage 0 - Responder received first message.");
      (0, _logger.logRemoteEphemeralKey)(this.session.hs.re);
    }
  } // stage 1


  async exchange() {
    if (this.isInitiator) {
      (0, _logger.logger)('Stage 1 - Initiator waiting to receive first message from responder...');
      const receivedMessageBuffer = (0, _encoder.decode1)((await this.connection.readLP()).slice());
      const {
        plaintext,
        valid
      } = this.xx.recvMessage(this.session, receivedMessageBuffer);

      if (!valid) {
        throw new Error("xx handshake stage 1 validation fail");
      }

      (0, _logger.logger)('Stage 1 - Initiator received the message.');
      (0, _logger.logRemoteEphemeralKey)(this.session.hs.re);
      (0, _logger.logRemoteStaticKey)(this.session.hs.rs);
      (0, _logger.logger)("Initiator going to check remote's signature...");

      try {
        const decodedPayload = await (0, _utils.decodePayload)(plaintext);
        this.remotePeer = this.remotePeer || (await (0, _utils.getPeerIdFromPayload)(decodedPayload));
        this.remotePeer = await (0, _utils.verifySignedPayload)(receivedMessageBuffer.ns, decodedPayload, this.remotePeer);
        this.setRemoteEarlyData(decodedPayload.data);
      } catch (e) {
        throw new Error(`Error occurred while verifying signed payload: ${e.message}`);
      }

      (0, _logger.logger)("All good with the signature!");
    } else {
      (0, _logger.logger)('Stage 1 - Responder sending out first message with signed payload and static key.');
      const messageBuffer = this.xx.sendMessage(this.session, this.payload);
      this.connection.writeLP((0, _encoder.encode1)(messageBuffer));
      (0, _logger.logger)('Stage 1 - Responder sent the second handshake message with signed payload.');
      (0, _logger.logLocalEphemeralKeys)(this.session.hs.e);
    }
  } // stage 2


  async finish() {
    if (this.isInitiator) {
      (0, _logger.logger)('Stage 2 - Initiator sending third handshake message.');
      const messageBuffer = this.xx.sendMessage(this.session, this.payload);
      this.connection.writeLP((0, _encoder.encode2)(messageBuffer));
      (0, _logger.logger)('Stage 2 - Initiator sent message with signed payload.');
    } else {
      (0, _logger.logger)('Stage 2 - Responder waiting for third handshake message...');
      const receivedMessageBuffer = (0, _encoder.decode2)((await this.connection.readLP()).slice());
      const {
        plaintext,
        valid
      } = this.xx.recvMessage(this.session, receivedMessageBuffer);

      if (!valid) {
        throw new Error("xx handshake stage 2 validation fail");
      }

      (0, _logger.logger)('Stage 2 - Responder received the message, finished handshake.');

      try {
        const decodedPayload = await (0, _utils.decodePayload)(plaintext);
        this.remotePeer = this.remotePeer || (await (0, _utils.getPeerIdFromPayload)(decodedPayload));
        await (0, _utils.verifySignedPayload)(this.session.hs.rs, decodedPayload, this.remotePeer);
        this.setRemoteEarlyData(decodedPayload.data);
      } catch (e) {
        throw new Error(`Error occurred while verifying signed payload: ${e.message}`);
      }
    }

    (0, _logger.logCipherState)(this.session);
  }

  encrypt(plaintext, session) {
    const cs = this.getCS(session);
    return this.xx.encryptWithAd(cs, _buffer.Buffer.alloc(0), plaintext);
  }

  decrypt(ciphertext, session) {
    const cs = this.getCS(session, false);
    return this.xx.decryptWithAd(cs, _buffer.Buffer.alloc(0), ciphertext);
  }

  getRemoteStaticKey() {
    return this.session.hs.rs;
  }

  getCS(session, encryption = true) {
    if (!session.cs1 || !session.cs2) {
      throw new Error("Handshake not completed properly, cipher state does not exist.");
    }

    if (this.isInitiator) {
      return encryption ? session.cs1 : session.cs2;
    } else {
      return encryption ? session.cs2 : session.cs1;
    }
  }

  setRemoteEarlyData(data) {
    if (data) {
      this.remoteEarlyData = _buffer.Buffer.from(data.buffer, data.byteOffset, data.length);
    }
  }

}

exports.XXHandshake = XXHandshake;
//# sourceMappingURL=handshake-xx.js.map