"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.XXFallbackHandshake = void 0;

var _buffer = require("buffer");

var _handshakeXx = require("./handshake-xx");

var _utils = require("./utils");

var _logger = require("./logger");

var _encoder = require("./encoder");

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class XXFallbackHandshake extends _handshakeXx.XXHandshake {
  constructor(isInitiator, payload, prologue, staticKeypair, connection, initialMsg, remotePeer, ephemeralKeys, handshake) {
    super(isInitiator, payload, prologue, staticKeypair, connection, remotePeer, handshake);

    _defineProperty(this, "ephemeralKeys", void 0);

    _defineProperty(this, "initialMsg", void 0);

    if (ephemeralKeys) {
      this.ephemeralKeys = ephemeralKeys;
    }

    this.initialMsg = initialMsg;
  } // stage 0


  async propose() {
    if (this.isInitiator) {
      this.xx.sendMessage(this.session, _buffer.Buffer.alloc(0), this.ephemeralKeys);
      (0, _logger.logger)("XX Fallback Stage 0 - Initialized state as the first message was sent by initiator.");
      (0, _logger.logLocalEphemeralKeys)(this.session.hs.e);
    } else {
      (0, _logger.logger)("XX Fallback Stage 0 - Responder decoding initial msg from IK.");
      const receivedMessageBuffer = (0, _encoder.decode0)(this.initialMsg);
      const {
        valid
      } = this.xx.recvMessage(this.session, {
        ne: receivedMessageBuffer.ne,
        ns: _buffer.Buffer.alloc(0),
        ciphertext: _buffer.Buffer.alloc(0)
      });

      if (!valid) {
        throw new Error("xx fallback stage 0 decryption validation fail");
      }

      (0, _logger.logger)("XX Fallback Stage 0 - Responder used received message from IK.");
      (0, _logger.logRemoteEphemeralKey)(this.session.hs.re);
    }
  } // stage 1


  async exchange() {
    if (this.isInitiator) {
      const receivedMessageBuffer = (0, _encoder.decode1)(this.initialMsg);
      const {
        plaintext,
        valid
      } = this.xx.recvMessage(this.session, receivedMessageBuffer);

      if (!valid) {
        throw new Error("xx fallback stage 1 decryption validation fail");
      }

      (0, _logger.logger)('XX Fallback Stage 1 - Initiator used received message from IK.');
      (0, _logger.logRemoteEphemeralKey)(this.session.hs.re);
      (0, _logger.logRemoteStaticKey)(this.session.hs.rs);
      (0, _logger.logger)("Initiator going to check remote's signature...");

      try {
        const decodedPayload = await (0, _utils.decodePayload)(plaintext);
        this.remotePeer = this.remotePeer || (await (0, _utils.getPeerIdFromPayload)(decodedPayload));
        await (0, _utils.verifySignedPayload)(this.session.hs.rs, decodedPayload, this.remotePeer);
        this.setRemoteEarlyData(decodedPayload.data);
      } catch (e) {
        throw new Error(`Error occurred while verifying signed payload from responder: ${e.message}`);
      }

      (0, _logger.logger)("All good with the signature!");
    } else {
      (0, _logger.logger)("XX Fallback Stage 1 - Responder start");
      await super.exchange();
      (0, _logger.logger)("XX Fallback Stage 1 - Responder end");
    }
  }

}

exports.XXFallbackHandshake = XXFallbackHandshake;
//# sourceMappingURL=handshake-xx-fallback.js.map